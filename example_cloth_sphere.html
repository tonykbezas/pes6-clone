<html lang="en">

<head>
    <title>Ammo.js Cloth + Sphere Demo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #61443e;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            background-color: #bfd1e5;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
        }

        a {
            color: #a06851;
        }
    </style>
</head>

<body>
    <div id="info">Ammo.js Cloth + Sphere Demo<br>Sphere falling on Soft Body Cloth</div>
    <div id="container"></div>

    <!-- CDNs -->
    <script src="https://cdn.jsdelivr.net/gh/kripken/ammo.js@HEAD/builds/ammo.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>

        Ammo().then(function (Ammo) {

            // - Global variables -

            // Graphics variables
            var container;
            var camera, controls, scene, renderer;
            var textureLoader;
            var clock = new THREE.Clock();

            // Physics variables
            var gravityConstant = -9.8;
            var collisionConfiguration;
            var dispatcher;
            var broadphase;
            var solver;
            var softBodySolver;
            var physicsWorld;
            var rigidBodies = [];
            var margin = 0.05;
            var cloth;
            var transformAux1 = new Ammo.btTransform();

            var time = 0;

            // - Main code -

            init();
            animate();


            // - Functions -

            function init() {

                initGraphics();

                initPhysics();

                createObjects();

            }

            function initGraphics() {

                container = document.getElementById('container');

                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 2000);

                scene = new THREE.Scene();

                camera.position.x = -12;
                camera.position.y = 7;
                camera.position.z = 4;

                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor(0xbfd1e5);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;

                // OrbitControls must be initialized AFTER renderer
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.target.y = 2;

                textureLoader = new THREE.TextureLoader();

                var ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);

                var light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(-7, 10, 15);
                light.castShadow = true;
                var d = 10;
                light.shadow.camera.left = -d;
                light.shadow.camera.right = d;
                light.shadow.camera.top = d;
                light.shadow.camera.bottom = -d;

                light.shadow.camera.near = 2;
                light.shadow.camera.far = 50;

                light.shadow.mapSize.x = 1024;
                light.shadow.mapSize.y = 1024;

                light.shadow.bias = -0.01;

                scene.add(light);

                container.innerHTML = "";

                container.appendChild(renderer.domElement);

                window.addEventListener('resize', onWindowResize, false);

            }

            function initPhysics() {

                // Physics configuration
                collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
                dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
                broadphase = new Ammo.btDbvtBroadphase();
                solver = new Ammo.btSequentialImpulseConstraintSolver();
                softBodySolver = new Ammo.btDefaultSoftBodySolver();
                physicsWorld = new Ammo.btSoftRigidDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
                physicsWorld.setGravity(new Ammo.btVector3(0, gravityConstant, 0));
                physicsWorld.getWorldInfo().set_m_gravity(new Ammo.btVector3(0, gravityConstant, 0));

            }

            function createObjects() {

                var pos = new THREE.Vector3();
                var quat = new THREE.Quaternion();

                // Ground
                pos.set(0, - 0.5, 0);
                quat.set(0, 0, 0, 1);
                var ground = createParalellepiped(40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial({ color: 0xFFFFFF }));
                ground.castShadow = true;
                ground.receiveShadow = true;

                var gridHelper = new THREE.GridHelper(40, 40, 0x000000, 0x000000);
                gridHelper.position.y = 0.01;
                scene.add(gridHelper);

                // The cloth
                var clothWidth = 4;
                var clothHeight = 4; // Square 4x4
                var clothNumSegmentsZ = clothWidth * 5;
                var clothNumSegmentsY = clothHeight * 5;
                var clothPos = new THREE.Vector3(0, 3, 0); // Centered

                var clothGeometry = new THREE.PlaneBufferGeometry(clothWidth, clothHeight, clothNumSegmentsZ, clothNumSegmentsY);
                clothGeometry.rotateX(-Math.PI * 0.5); // Flat horizontal
                clothGeometry.translate(clothPos.x, clothPos.y, clothPos.z);

                var clothMaterial = new THREE.MeshLambertMaterial({ color: 0x0030A0, side: THREE.DoubleSide, wireframe: true });
                cloth = new THREE.Mesh(clothGeometry, clothMaterial);
                cloth.castShadow = true;
                cloth.receiveShadow = true;
                scene.add(cloth);

                // Cloth physic object
                var softBodyHelpers = new Ammo.btSoftBodyHelpers();
                var clothCorner00 = new Ammo.btVector3(clothPos.x - clothWidth / 2, clothPos.y, clothPos.z - clothHeight / 2);
                var clothCorner01 = new Ammo.btVector3(clothPos.x + clothWidth / 2, clothPos.y, clothPos.z - clothHeight / 2);
                var clothCorner10 = new Ammo.btVector3(clothPos.x - clothWidth / 2, clothPos.y, clothPos.z + clothHeight / 2);
                var clothCorner11 = new Ammo.btVector3(clothPos.x + clothWidth / 2, clothPos.y, clothPos.z + clothHeight / 2);

                var clothSoftBody = softBodyHelpers.CreatePatch(physicsWorld.getWorldInfo(), clothCorner00, clothCorner01, clothCorner10, clothCorner11, clothNumSegmentsZ + 1, clothNumSegmentsY + 1, 0, true);
                var sbConfig = clothSoftBody.get_m_cfg();
                sbConfig.set_viterations(10);
                sbConfig.set_piterations(10);

                clothSoftBody.setTotalMass(0.9, false)
                Ammo.castObject(clothSoftBody, Ammo.btCollisionObject).getCollisionShape().setMargin(margin * 3);
                physicsWorld.addSoftBody(clothSoftBody, 1, -1);
                cloth.userData.physicsBody = clothSoftBody;
                clothSoftBody.setActivationState(4);

                // Poles
                var poleHeight = 3.5;
                var poleWidth = 0.2;
                var poleMaterial = new THREE.MeshPhongMaterial({ color: 0x606060 });
                var poles = [];
                var polePositions = [
                    { x: clothPos.x - clothWidth / 2, z: clothPos.z - clothHeight / 2 }, // Corner 00
                    { x: clothPos.x + clothWidth / 2, z: clothPos.z - clothHeight / 2 }, // Corner 01
                    { x: clothPos.x - clothWidth / 2, z: clothPos.z + clothHeight / 2 }, // Corner 10
                    { x: clothPos.x + clothWidth / 2, z: clothPos.z + clothHeight / 2 }  // Corner 11
                ];

                for (var i = 0; i < polePositions.length; i++) {
                    var pos = new THREE.Vector3(polePositions[i].x, poleHeight / 2, polePositions[i].z);
                    var quat = new THREE.Quaternion(0, 0, 0, 1);
                    var pole = createParalellepiped(poleWidth, poleHeight, poleWidth, 0, pos, quat, poleMaterial);
                    pole.castShadow = true;
                    pole.receiveShadow = true;
                    poles.push(pole);
                }

                // Pin corners to poles
                var nZ = clothNumSegmentsZ + 1;
                var nY = clothNumSegmentsY + 1;
                var influence = 1;

                clothSoftBody.appendAnchor(0, poles[0].userData.physicsBody, true, influence);
                clothSoftBody.appendAnchor(nZ - 1, poles[1].userData.physicsBody, true, influence);
                clothSoftBody.appendAnchor((nY - 1) * nZ, poles[2].userData.physicsBody, true, influence);
                clothSoftBody.appendAnchor(nY * nZ - 1, poles[3].userData.physicsBody, true, influence);

                // Sphere
                var sphereMass = 1;
                var sphereRadius = 0.5;
                pos.set(0, 6, 0); // Above cloth
                quat.set(0, 0, 0, 1);
                var sphere = createSphere(sphereRadius, sphereMass, pos, quat, new THREE.MeshPhongMaterial({ color: 0xFF0000 }));
                sphere.castShadow = true;
                sphere.receiveShadow = true;

            }

            function createParalellepiped(sx, sy, sz, mass, pos, quat, material) {

                var threeObject = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), material);
                var shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
                shape.setMargin(margin);

                createRigidBody(threeObject, shape, mass, pos, quat);

                return threeObject;

            }

            function createSphere(radius, mass, pos, quat, material) {
                var threeObject = new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), material);
                var shape = new Ammo.btSphereShape(radius);
                shape.setMargin(margin);
                createRigidBody(threeObject, shape, mass, pos, quat);
                return threeObject;
            }

            function createRigidBody(threeObject, physicsShape, mass, pos, quat) {

                threeObject.position.copy(pos);
                threeObject.quaternion.copy(quat);

                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
                transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
                var motionState = new Ammo.btDefaultMotionState(transform);

                var localInertia = new Ammo.btVector3(0, 0, 0);
                if (mass > 0) {
                    physicsShape.calculateLocalInertia(mass, localInertia);
                }

                var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
                var body = new Ammo.btRigidBody(rbInfo);

                threeObject.userData.physicsBody = body;

                scene.add(threeObject);

                if (mass > 0) {
                    rigidBodies.push(threeObject);
                    body.setActivationState(4);
                }

                physicsWorld.addRigidBody(body);

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);

            }

            function animate() {

                requestAnimationFrame(animate);

                render();

            }

            function render() {

                var deltaTime = clock.getDelta();

                updatePhysics(deltaTime);

                controls.update(deltaTime);

                renderer.render(scene, camera);

                time += deltaTime;

            }

            function updatePhysics(deltaTime) {

                physicsWorld.stepSimulation(deltaTime, 10);

                // Update cloth
                var softBody = cloth.userData.physicsBody;
                var clothPositions = cloth.geometry.attributes.position.array;
                var numVerts = clothPositions.length / 3;
                var nodes = softBody.get_m_nodes();
                var indexFloat = 0;
                for (var i = 0; i < numVerts; i++) {
                    var node = nodes.at(i);
                    var nodePos = node.get_m_x();
                    clothPositions[indexFloat++] = nodePos.x();
                    clothPositions[indexFloat++] = nodePos.y();
                    clothPositions[indexFloat++] = nodePos.z();
                }
                cloth.geometry.computeVertexNormals();
                cloth.geometry.attributes.position.needsUpdate = true;
                cloth.geometry.attributes.normal.needsUpdate = true;

                // Update rigid bodies
                for (var i = 0, il = rigidBodies.length; i < il; i++) {
                    var objThree = rigidBodies[i];
                    var objPhys = objThree.userData.physicsBody;
                    var ms = objPhys.getMotionState();
                    if (ms) {
                        ms.getWorldTransform(transformAux1);
                        var p = transformAux1.getOrigin();
                        var q = transformAux1.getRotation();
                        objThree.position.set(p.x(), p.y(), p.z());
                        objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
                    }
                }

            }

        });

    </script>

</body>

</html>